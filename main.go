//go:generate go run main.go

package main

import (
	"cloud.google.com/go/bigquery"
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"runtime"
)

const (
	optNameProjectID                    = "project"
	optNameDataset                      = "dataset"
	optNameKeyFile                      = "keyfile"
	optNameOutputPath                   = "output"
	envNameGoogleApplicationCredentials = "GOOGLE_APPLICATION_CREDENTIALS"
)

var (
	vOptProjectID  string
	vOptDataset    string
	vOptKeyFile    string
	vOptOutputPath string
)

func init() {
	flag.StringVar(&vOptProjectID, optNameProjectID, "", "")
	flag.StringVar(&vOptDataset, optNameDataset, "", "")
	flag.StringVar(&vOptKeyFile, optNameKeyFile, "", "path to service account json key file")
	flag.StringVar(&vOptOutputPath, optNameOutputPath, "", "path to output the generated code")
	flag.Parse()
}

const (
	goFileContentHeader = `// Code generated by bqtableschema.go; DO NOT EDIT.

package bqtableschema
`
)

func main() {
	ctx := context.Background()

	// output 1
	fmt.Printf("%s\n", goFileContentHeader)

	projectID, err := getGoogleProject()
	if err != nil {
		log.Fatalf("%s: %v\n", FuncNameWithFileInfo(), err)
	}

	c, err := bigquery.NewClient(ctx, projectID)
	defer func() {
		if err := c.Close(); err != nil {
			log.Fatalf("%s: %v", FuncNameWithFileInfo(), err)
		}
	}()
	if err != nil {
		log.Fatalf("%s: %v\n", FuncNameWithFileInfo(), err)
	}

	_ = c

}

type googleApplicationCredentials struct {
	Type                    string `json:"type"`
	ProjectID               string `json:"project_id"`
	PrivateKeyID            string `json:"private_key_id"`
	PrivateKey              string `json:"private_key"`
	ClientEmail             string `json:"client_email"`
	ClientID                string `json:"client_id"`
	AuthURI                 string `json:"auth_uri"`
	TokenURI                string `json:"token_uri"`
	AuthProviderX509CertURL string `json:"auth_provider_x509_cert_url"`
	ClientX509CertURL       string `json:"client_x509_cert_url"`
}

func getGoogleProject() (string, error) {
	path := os.Getenv(envNameGoogleApplicationCredentials)

	switch {
	case vOptProjectID != "":
		return vOptProjectID, nil
	case path != "":
		return getGoogleProjectByGoogleApplicationCredentials(path)
	case vOptOutputPath != "":
		return getGoogleProjectByGoogleApplicationCredentials(vOptOutputPath)
	default:
		return "", fmt.Errorf("%s: set option -%s, or set environment variable %s", FuncNameWithFileInfo(), optNameKeyFile, envNameGoogleApplicationCredentials)
	}

}

func getGoogleProjectByGoogleApplicationCredentials(path string) (string, error) {
	file, err := os.Open(path)
	if err != nil {
		return "", fmt.Errorf("%s: %w", FuncNameWithFileInfo(), err)
	}

	content, err := ioutil.ReadAll(file)
	if err != nil {
		return "", fmt.Errorf("getGoogleProject: %w", err)
	}

	cred := googleApplicationCredentials{}
	if err := json.Unmarshal(content, &cred); err != nil {
		return "", fmt.Errorf("getGoogleProject: %w", err)
	}

	return cred.ProjectID, nil
}

// ResolveEnvs resolves environment variables from the arguments passed as environment variable names.
func ResolveEnvs(keys ...string) (map[string]string, error) {
	envs := map[string]string{}

	for _, key := range keys {
		envs[key] = os.Getenv(key)
		if envs[key] == "" {
			return nil, fmt.Errorf("%s: environment variable %s is empty", FuncNameWithFileInfo(), key)
		}
	}

	return envs, nil
}

// MergeMap merge map[string]string
func MergeMap(sideToBeMerged, sideToMerge map[string]string) map[string]string {
	m := map[string]string{}

	for k, v := range sideToBeMerged {
		m[k] = v
	}
	for k, v := range sideToMerge {
		m[k] = v
	}
	return (m)
}

type caller struct {
	initialized bool
	pc          uintptr
	file        string
	line        int
}

func (c *caller) PC() uintptr {
	if !c.initialized {
		runtime.Caller(1)
	}
	if c == nil {
		return 0
	}
	return c.pc
}

func (c *caller) File() string {
	if c == nil {
		return "unknown"
	}
	return c.file
}

func (c *caller) Line() int {
	if c == nil {
		return 0
	}
	return c.line
}

func FuncName() string {
	pc, _, _, ok := runtime.Caller(1)
	if !ok {
		return ""
	}
	return runtime.FuncForPC(pc).Name()
}

func FuncNameWithFileInfo() string {
	pc, file, line, ok := runtime.Caller(1)
	if !ok {
		return ""
	}
	return fmt.Sprintf("%s[%s:%d]", runtime.FuncForPC(pc).Name(), filepath.Base(file), line)
}
