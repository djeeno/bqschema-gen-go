//go:generate go run github.com/djeeno/bqtableschema/generator.go

package main

import (
	"cloud.google.com/go/bigquery"
	"context"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"google.golang.org/api/iterator"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

const (
	optNameProjectID                    = "project"
	optNameDataset                      = "dataset"
	optNameKeyFile                      = "keyfile"
	optNameOutputPath                   = "output"
	envNameGoogleApplicationCredentials = "GOOGLE_APPLICATION_CREDENTIALS"
)

var (
	ErrNoGoogleApplicationCredentials = fmt.Errorf("set environment variable %s, or set option -%s", envNameGoogleApplicationCredentials, optNameKeyFile)
	ErrTableNameIsEmpty               = errors.New("tableName is empty")
)

var (
	vOptProjectID  string
	vOptDataset    string
	vOptKeyFile    string
	vOptOutputPath string
)

func init() {
	flag.StringVar(&vOptProjectID, optNameProjectID, "", "")
	flag.StringVar(&vOptDataset, optNameDataset, "", "")
	flag.StringVar(&vOptKeyFile, optNameKeyFile, "", "path to service account json key file")
	flag.StringVar(&vOptOutputPath, optNameOutputPath, "", "path to output the generated code")
	flag.Parse()
}

const (
	generatedPackage       = "bqtableschema"
	generatedContentHeader = "// Code generated by go run github.com/djeeno/bqtableschema/generator.go; DO NOT EDIT.\n\npackage " + generatedPackage + "\n\n"
)

func main() {
	ctx := context.Background()

	if err := run(ctx); err != nil {
		log.Fatalf("run: %v\n", err)
	}
}

// run is effectively a `main` function.
// It is separated from the `main` function because of addressing an issue where` defer` is not executed when `os.Exit` is executed.
func run(ctx context.Context) error {
	var gen string

	// NOTE(djeeno): add header
	gen = gen + generatedContentHeader

	// NOTE(djeeno): if passed -keyfile,
	if vOptKeyFile != "" {
		if err := os.Setenv(envNameGoogleApplicationCredentials, vOptKeyFile); err != nil {
			return fmt.Errorf("os.Setenv: %w", err)
		}
	}

	envKeyFile := os.Getenv(envNameGoogleApplicationCredentials)

	if envKeyFile == "" {
		return ErrNoGoogleApplicationCredentials
	}

	cred, err := newGoogleApplicationCredentials(envKeyFile)
	if err != nil {
		return fmt.Errorf("newGoogleApplicationCredentials: %w", err)
	}

	var projectID string
	if vOptProjectID != "" {
		projectID = vOptProjectID
	} else {
		projectID = cred.ProjectID
	}

	c, err := bigquery.NewClient(ctx, projectID)
	if err != nil {
		return fmt.Errorf("bigquery.NewClient: %w", err)
	}
	defer func() {
		if err := c.Close(); err != nil {
			log.Printf("c.Close: %v\n", err)
		}
	}()

	tables, err := getAllTables(ctx, c, vOptDataset)
	if err != nil {
		return fmt.Errorf("getAllTables: %w", err)
	}

	for i, table := range tables {
		if len(table.TableID) == 0 {
			return ErrTableNameIsEmpty
		}

		head := table.TableID[:1] // NOTE(djeeno): first letter
		tail := table.TableID[1:] // NOTE(djeeno): 2nd and subsequent characters. if len(s) == 1, return ""
		structName := strings.ToUpper(head) + tail

		// NOTE(djeeno): add structs
		gen = gen + fmt.Sprintf("// %s is Big Query table name.\n", structName)
		gen = gen + fmt.Sprintf("type %s struct {\n", structName)
		gen = gen + "\t// DEBUG: define structs fields\n"
		gen = gen + "}\n"

		if !isLastLoop(i, len(tables)) {
			gen = gen + "\n"
		}
	}

	// NOTE(djeeno): output
	fmt.Print(gen)

	return nil
}

func getAllTables(ctx context.Context, c *bigquery.Client, datasetID string) (tables []*bigquery.Table, err error) {
	tableIterator := c.Dataset(datasetID).Tables(ctx)
	for {
		table, err := tableIterator.Next()
		if err != nil {
			if err == iterator.Done {
				break
			}
			return nil, fmt.Errorf("tableIterator.Next: %w", err)
		}
		tables = append(tables, table)
	}
	return tables, nil
}

type googleApplicationCredentials struct {
	Type                    string `json:"type"`
	ProjectID               string `json:"project_id"`
	PrivateKeyID            string `json:"private_key_id"`
	PrivateKey              string `json:"private_key"`
	ClientEmail             string `json:"client_email"`
	ClientID                string `json:"client_id"`
	AuthURI                 string `json:"auth_uri"`
	TokenURI                string `json:"token_uri"`
	AuthProviderX509CertURL string `json:"auth_provider_x509_cert_url"`
	ClientX509CertURL       string `json:"client_x509_cert_url"`
}

func newGoogleApplicationCredentials(path string) (*googleApplicationCredentials, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("%s: %w", caller(), err)
	}

	bytea, err := ioutil.ReadAll(file)
	if err != nil {
		return nil, fmt.Errorf("%s: %w", caller(), err)
	}

	cred := googleApplicationCredentials{}
	if err := json.Unmarshal(bytea, &cred); err != nil {
		return nil, fmt.Errorf("%s: %w", caller(), err)
	}

	return &cred, nil
}

func isLastLoop(loopIndex, lengthOfLoop int) bool {
	return loopIndex+1 == lengthOfLoop
}

// resolveEnvs resolves environment variables from the arguments passed as environment variable names.
func resolveEnvs(keys ...string) (map[string]string, error) {
	envs := map[string]string{}

	for _, key := range keys {
		envs[key] = os.Getenv(key)
		if envs[key] == "" {
			return nil, fmt.Errorf("%s: environment variable %s is empty", caller(), key)
		}
	}

	return envs, nil
}

// mergeMap merge map[string]string
func mergeMap(sideToBeMerged, sideToMerge map[string]string) map[string]string {
	m := map[string]string{}

	for k, v := range sideToBeMerged {
		m[k] = v
	}
	for k, v := range sideToMerge {
		m[k] = v
	}
	return (m)
}

func funcName() string {
	pc, _, _, ok := runtime.Caller(1)
	if !ok {
		return ""
	}
	return runtime.FuncForPC(pc).Name()
}

func caller() string {
	pc, file, line, ok := runtime.Caller(1)
	if !ok {
		return fmt.Sprintf("%s[%s:%d]", "null", "null", 0)
	}
	return fmt.Sprintf("%s[%s:%d]", runtime.FuncForPC(pc).Name(), filepath.Base(file), line)
}
